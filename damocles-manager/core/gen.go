//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"

	"golang.org/x/exp/slices"
)

const apiTemplate = `
// Generated by gen.go. Do not edit.

package {{.Package}}

import (
{{range $key, $value := .Imports}}  {{$value}} {{$key}}
{{end}})

{{range .APIs}}
// {{.Type}}Client is generated client for {{.Type}} interface.
type {{.Type}}Client struct {
{{range .Methods}}
{{.Name}} func({{.Parameters | functionargs}}) ({{.Results | functionargs}}{{if .Results}}, {{end}}){{end}}
}

{{$type := .Type}}
var Unavailable{{.Type}}Client = {{.Type}}Client{
{{range .Methods}}
{{.Name}}: func({{.Parameters | functionargs}}) ({{.Results | functionargs}}{{if .Results}}, {{end}}) {
	panic("{{$type}} client unavailable")
},{{end}}
}

{{end}}
`

var (
	interfaceNames = flag.String("interface", "", "comma-separated list of interface names; must be set")
	output         = flag.String("output", "", "output file name; default srcdir/client.go")
)

func main() {
	log.SetFlags(0)
	log.SetPrefix("gen: ")
	flag.Parse()

	if len(*interfaceNames) == 0 {
		flag.Usage()
		os.Exit(2)
	}
	srcFile := os.Getenv("GOFILE")
	allowTypes := strings.Split(*interfaceNames, ",")

	fileset := token.NewFileSet()
	f, err := parser.ParseFile(fileset, srcFile, nil, 0)
	if err != nil {
		log.Fatalf("failed to parse %s: %s", srcFile, err)
	}
	g := &Generator{
		Package:    f.Name.Name,
		allowTypes: allowTypes,
		fileset:    fileset,
		Imports:    make(map[string]string),
	}
	ast.Walk(g, f)

	funcs := map[string]interface{}{
		"functionargs": func(fields []*Type) string { return FieldList(fields, "", ", ", true) },
	}
	t, err := template.New("client").Funcs(funcs).Parse(apiTemplate)
	if err != nil {
		log.Fatalf("failed to parse template: %s", err)
	}
	buf := bytes.Buffer{}
	err = t.Execute(&buf, g)
	if err != nil {
		log.Fatalf("failed to execute template: %s", err)
	}

	// Write to file.
	outputName := *output
	if outputName == "" {
		outputName = "client_gen.go"
	}
	dst, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("failed to format code: %s", err)
	}
	err = os.WriteFile(outputName, dst, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// isDirectory reports whether the named file is a directory.
func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

func FieldList(fields []*Type, prefix string, delim string, withTypes bool) string {
	var out []string
	for _, p := range fields {
		suffix := ""
		if withTypes {
			suffix = " " + p.Type
		}
		names := p.Names
		var field []string
		for _, n := range names {
			field = append(field, prefix+n)
		}
		out = append(out, strings.Join(field, ", ")+suffix)
	}
	return strings.Join(out, delim)
}

type Type struct {
	Names []string
	Type  string
}

func (t *Type) NamesString() string {
	return strings.Join(t.Names, ", ")
}

type Method struct {
	Name       string
	Parameters []*Type
	Results    []*Type
}

type API struct {
	Type    string
	Methods []*Method
}

type Generator struct {
	fileset    *token.FileSet
	allowTypes []string

	Package string
	Imports map[string]string
	APIs    []API
}

func (g *Generator) Visit(node ast.Node) (w ast.Visitor) {
	switch n := node.(type) {
	case *ast.ImportSpec:
		if n.Name != nil {
			g.Imports[n.Path.Value] = n.Name.Name
		} else {
			g.Imports[n.Path.Value] = ""
		}
	case *ast.TypeSpec:
		name := n.Name.Name
		if slices.Contains(g.allowTypes, name) {
			return &InterfaceGen{Generator: g, Name: name}
		}
	}
	return g
}

type InterfaceGen struct {
	*Generator
	Name string
}

func (ig *InterfaceGen) VisitMethodList(n *ast.InterfaceType) {
	client := API{
		Type:    ig.Name,
		Methods: []*Method{},
	}
	for _, m := range n.Methods.List {
		switch t := m.Type.(type) {
		case *ast.FuncType:
			method := &Method{
				Name:       m.Names[0].Name,
				Parameters: make([]*Type, 0),
				Results:    make([]*Type, 0),
			}
			for _, v := range t.Params.List {
				method.Parameters = append(method.Parameters, ig.formatType(ig.fileset, v))
			}
			hasError := false
			if t.Results != nil {
				for _, v := range t.Results.List {
					result := ig.formatType(ig.fileset, v)
					if result.Type == "error" {
						hasError = true
					}
					method.Results = append(method.Results, result)
				}
			}
			if !hasError {
				fatalNode(ig.fileset, m, "method %s must have error as last return value", method.Name)
			}
			client.Methods = append(client.Methods, method)
		case *ast.Ident:
			// Embedded interface
			ig.VisitMethodList(t.Obj.Decl.(*ast.TypeSpec).Type.(*ast.InterfaceType))
		}
	}
	ig.APIs = append(ig.APIs, client)
}

func (ig *InterfaceGen) Visit(node ast.Node) (w ast.Visitor) {
	switch n := node.(type) {
	case *ast.InterfaceType:
		ig.VisitMethodList(n)
	}
	return ig.Generator
}

func (ig *InterfaceGen) formatType(fileset *token.FileSet, field *ast.Field) *Type {
	var typeBuf bytes.Buffer
	_ = printer.Fprint(&typeBuf, fileset, field.Type)
	t := &Type{Type: typeBuf.String()}
	for _, n := range field.Names {
		t.Names = append(t.Names, n.Name)
	}
	return t
}

func fatalNode(fileset *token.FileSet, node ast.Node, format string, args ...interface{}) {
	log.Fatalf("%s: error: %s: %s\n", os.Args[0], fileset.Position(node.Pos()).String(), fmt.Sprintf(format, args...))
	os.Exit(1)
}
